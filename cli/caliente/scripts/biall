#!/bin/bash
SCRIPT="$(readlink -f "${0}")"
BASEDIR="$(dirname "${0}")"
SCRIPT="$(basename "${0}")"

INDEX="CALIENTE_INGESTION_INDEX.txt"

DATEMARK="$(date +%Y%m%d-%H%M%S)"

INDEX_MAP="${BASEDIR}/${SCRIPT}.${DATEMARK}.postproc"

DEBUG="false"

# Open up the log on file descriptor 9, if it's not already open
LOG="${BASEDIR}/${SCRIPT}.${DATEMARK}.log"

init_log() {
	[ -f /dev/fd/9 ] || exec 9>"${LOG}" || {
		echo "FAILED TO INITIALIZE THE LOG AT [${LOG}]"
		exit 9
	}
}

datemark() {
	date -Iseconds
}

say() {
	init_log
	echo -e "$(datemark): ${@}" | tee -a /dev/fd/9
}

silent_log() {
	init_log
	tee -a /dev/fd/9 &>/dev/null
}

log() {
	say "${@}" &>/dev/null
}

err() {
	echo -e "${@}" 1>&2
}

fail() {
	err "ERROR: ${@}"
	exit 1
}

usage() {
	err "usage: ${SCRIPT} [-c] -h alfrescoUrl [-u user -p password | -A authenticationFile] [-P] [-W pollSec] directories..."
	for e in "${@}" ; do
		err "\t${e}"
	done
	exit 1
}

parse_value() {
	parse --raw-output "${@}"
}

parse() {
	"${JQ}" "${@}"
}

find_script() {
	local EXE_NAME="${1}"
	local REQUIRED="${2}"
	REQUIRED="${REQUIRED,,}"
	case "${REQUIRED}" in
		true | false ) ;;
		* ) REQUIRED="false" ;;
	esac

	local EXE="${BASEDIR}/${EXE_NAME}"
	[ -f "${EXE}" ] || { ${REQUIRED} && fail "'${EXE_NAME}' is not installed, but is required by this script" ; return 1 ; }
	[ -x "${EXE}" ] || { ${REQUIRED} && fail "'${EXE}' is not executable, but is required by this script" ; return 2 ; }
	echo "${EXE}"
	return 0
}

find_exe() {
	local EXE_NAME="${1}"
	local REQUIRED="${2}"
	REQUIRED="${REQUIRED,,}"
	case "${REQUIRED}" in
		true | false ) ;;
		* ) REQUIRED="false" ;;
	esac

	local EXE="$(which "${EXE_NAME}")"
	[ -z "${EXE}" ] && EXE="/usr/bin/${EXE_NAME}"
	[ -f "${EXE}" ] || { ${REQUIRED} && fail "'${EXE_NAME}' is not installed, but is required by this script" ; return 1 ; }
	[ -x "${EXE}" ] || { ${REQUIRED} && fail "'${EXE}' is not executable, but is required by this script" ; return 2 ; }
	echo "${EXE}"
	return 0
}

handle_bi_error() {
	local DIR="${1}"
	local RC="${2}"
	local OUT="${3}"

	${IGNORE_ERRORS} && return 0
	return ${RC}
}

handle_pp_error() {
	local DIR="${1}"
	local RC="${2}"
	local OUT="${3}"

	say "${OUT}"
	say "RC=[${RC}]"
	${IGNORE_ERRORS} && return 0
	return ${RC}
}

get_suffix() {
	local DIR="${1}"
	echo ""
}

normalize_path() {
	# Remove all . and .. sequences
	# Returns 0 if successful, 1 if the .. recursion goes too far up
	local SRC=()
	local TGT=()
	local IDX=()
	IFS="/" read -r -a SRC <<< "${1}"
	local LEADING=false
	local FIRST=true
	for e in "${SRC[@]}" ; do
		case "${e}" in
			.. )
				[ ${#TGT[@]} -lt 1 ] && return 1
				IDX=(${!TGT[@]});
				unset TGT[${IDX[@]: -1}]
				;;
			"" ) ${FIRST} && LEADING=true ;;
			. ) ;; # Do nothing - must be silently skipped
			* ) TGT+=("${e}") ;;
		esac
		FIRST=false
	done
	${LEADING} || FIRST=true
	for e in "${TGT[@]}" ; do
		${FIRST} || echo -en "/"
		echo -en "${e}"
		FIRST=false
	done
	${FIRST} && echo -en "/"
	echo ""
	return 0
}

process() {
	local DIR="${1}"
	local TGT="${2}"

	local OUT=""
	local RC=0

	local IDX="${INDEX}"

	[ -f "${DIR}/${IDX}" ] || return 0

	# Only rename the ingestion index if we're not running PP in this same batch
	local SUFFIX="$(get_suffix "${DIR}")"
	[ -z "${SUFFIX}" ] && SUFFIX="$(uuidgen -t)"
	IDX="${INDEX}.${SUFFIX}"

	say "Renaming the PP index file for [${DIR}] with the suffix [${SUFFIX}]..."
	"${XMLSTARLET}" ed -L \
		-u "/scan/item[sourceName=\"${INDEX}\"]/targetName" -v "${IDX}" \
		"${DIR}/scan.files.xml" |& sed -e 's/^/\t/g' | silent_log
	RC="${?}"
	log "RC=[${RC}]"
	[ ${RC} -eq 0 ] || return ${RC}

	if ! ${LAUNCH_PP} ; then
		say "Writing out the mapping for [${DIR}] to [${SUFFIX}]"
		echo -e "${IDX}\t${TARGET}" >> "${INDEX_MAP}"
	fi

	say "Launching BI for [${DIR}]..."
	"${BILAUNCH}" ${CURL} -u "${ALF_USER}" -p "${ALF_PASS}" -h "${ALF_URL}" -s "${DIR}" -t "${TGT}" ${DRYRUN} ${REPLACE} |& silent_log
	RC="${?}"
	log "RC=[${RC}]"
	[ ${RC} -eq 0 ] || return ${RC}

	say "Waiting for BI for [${DIR}]..."
	"${BICHECK}" ${CURL} -u "${ALF_USER}" -p "${ALF_PASS}" -h "${ALF_URL}" -w -W ${POLLSEC} |& silent_log
	RC="${?}"
	log "RC=[${RC}]"
	[ ${RC} -eq 0 ] || ${IGNORE_ERRORS} || return ${RC}

	say "BI Completed for [${DIR}]..."

	${LAUNCH_PP} || return 0

	say "Launching PP for [${DIR}]..."
	"${PPLAUNCH}" ${CURL} -u "${ALF_USER}" -p "${ALF_PASS}" -h "${ALF_URL}" -s "${TGT}" -i "${IDX}" |& silent_log
	RC="${?}"
	log "RC=[${RC}]"
	[ ${RC} -eq 0 ] || return ${RC}

	say "Waiting for PP for [${DIR}]..."
	"${PPCHECK}" ${CURL} -u "${ALF_USER}" -p "${ALF_PASS}" -h "${ALF_URL}" -w -W ${POLLSEC} |& silent_log
	RC=${?}
	log "RC=[${RC}]"
	[ ${RC} -eq 0 ] || ${IGNORE_ERRORS} || return ${RC}

	return 0
}

ALF_URL=""
ALF_USER=""
ALF_PASS=""
ALF_PASS_SET="false"
PREFER_CURL="false"

LAUNCH_PP="false"
IGNORE_ERRORS="false"
MIN_POLLSEC="3"
POLLSEC="30"
POLLSEC_SET="false"

while getopts ":ch:u:p:A:t:PIW:" OPT "${@}" ; do
	case "${OPT}" in
		c )	${PREFER_CURL} && fail "May not specify -c more than once"
			PREFER_CURL="true"
			;;
		h )	[ -n "${ALF_URL}" ] && fail "May not specify more than one -h value"
			[ -z "${OPTARG}" ] && fail "May not specify an empty URL"
			ALF_URL="${OPTARG}"
			;;
		u )	[ -n "${ALF_USER}" ] && fail "May not specify more than one -u value"
			[ -n "${ALF_AUTH}" ] && fail "May not specify -A and -u"
			[ -z "${OPTARG}" ] && fail "May not specify an empty username"
			ALF_USER="${OPTARG}"
			;;
		p )	${ALF_PASS_SET} && fail "May not specify more than one -p value"
			[ -n "${ALF_AUTH}" ] && fail "May not specify -A and -p"
			ALF_PASS="${OPTARG}"
			ALF_PASS_SET="true"
			;;
		A )	[ -n "${ALF_USER}" ] && fail "May not specify -u and -A"
			${ALF_PASS_SET} && fail "May not specify -p and -A"
			[ -z "${OPTARG}" ] && fail "May not specify an empty authentication file"
			ALF_AUTH="${OPTARG}"
			[ -e "${ALF_AUTH}" ] || fail "The authentication file [${ALF_AUTH}] does not exist"
			[ -f "${ALF_AUTH}" ] || fail "The authentication file [${ALF_AUTH}] is not a regular file"
			[ -r "${ALF_AUTH}" ] || fail "The authentication file [${ALF_AUTH}] can't be read"
			;;
		P ) ${LAUNCH_PP} && fail "May not specify -P more than once"
			LAUNCH_PP="true"
			;;
		t )	[ -n "${TARGET}" ] && fail "May not specify -t more than once"
			[ -z "${OPTARG}" ] && fail "May not specify an empty target path"
			TARGET="$(normalize_path "${OPTARG}")"
			[ ${?} -ne 0 ] && fail "Illegal target path [${OPTARG}] - not fully normalized"
			;;
		I ) ${IGNORE_ERRORS} && fail "May not specify -I more than once"
			IGNORE_ERRORS="true"
			;;
		W )	${POLLSEC_SET} && fail "May not specify -W more than once"
			POLLSEC="${OPTARG}"
			[[ "${POLLSEC}" =~ ^[1-9][0-9]* ]] || fail "The value [${POLLSEC}] is not a valid number"
			if [ ${POLLSEC} -lt ${MIN_POLLSEC} ] ; then
				POLLSEC=${MIN_POLLSEC}
				err "Polling interval may not be less than ${POLLSEC} seconds"
			fi
			POLLSEC_SET="true"
			;;
		? )	OI="$(( OPTIND - 1 ))"
			usage "Parameter ${!OI} is not valid or unexpected here"
			;;
	esac
done

shift $(( OPTIND - 1 ))

[ -z "${TARGET}" ] && usage "May not specify an empty target path"
[ -z "${ALF_URL}" ] && usage "-h requires a non-empty value"
[ -z "${ALF_USER}" -a -z "${ALF_AUTH}" ] && usage "Must provide either -u or -A"
[ -n "${ALF_USER}" ] && ! ${ALF_PASS_SET} && usage "Must provide a password using -p, or use -A"

XMLSTARLET="$(find_exe xmlstarlet true)"
BILAUNCH="$(find_script bilaunch true)"
BICHECK="$(find_script bicheck true)"
BIERR="$(find_script bierr true)"

PPLAUNCH="$(find_script pplaunch ${LAUNCH_PP})"
PPCHECK="$(find_script ppcheck ${LAUNCH_PP})"

if ${DEBUG} ; then
	BILAUNCH="/bin/echo"
	BICHECK="/bin/echo"
	BIERR="/bin/echo"

	PPLAUNCH="/bin/echo"
	PPCHECK="/bin/echo"
fi

CURL=""
${PREFER_CURL} && CURL="-c"

if [ -n "${ALF_AUTH}" ] ; then
	AUTH_DATA="$(cat "${ALF_AUTH}")"
	parse "." <<< "${AUTH_DATA}" &>/dev/null || fail "The authentication file [${ALF_AUTH}] must have proper JSON syntax"
	ALF_USER="$(parse_value ".user" <<< "${AUTH_DATA}")"
	ALF_PASS="$(parse_value ".password" <<< "${AUTH_DATA}")"
	ALF_PASS_SET="true"
fi


for dir in "${@}" ; do
	dir="$(readlink -f "${dir}")"
	[ -z "${dir}" ] && continue
	[ -e "${dir}" ] || continue
	[ -d "${dir}" ] || continue
	[ -r "${dir}" ] || continue
	[ -x "${dir}" ] || continue
	find "${dir}" -type d -name bulk-import-root | while read candidate ; do
		candidate="$(readlink -f "${candidate}")"
		process "${candidate}" "${TARGET}" || exit ${?}
	done
done
